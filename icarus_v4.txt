//+------------------------------------------------------------------+
//|                                                    obscalper.mq4 |
//|                        Copyright 2020, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2020, MetaQuotes Software Corp."
#property link      "https://www.mql5.com"
#property version   "1.00"
#property strict

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+

class setupTrades
  {
public:
   double            price;
   double            stop;
   double            tp;
   datetime          date;
   int               timeframe;
   int               pos;
   bool              on;
   string            symb;
   double            open;
   double            close;
   datetime          bartime;
                     setupTrades() {};
                     setupTrades(const setupTrades& that);
  };

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
class liq
  {
public:
   double            price;
   int               timeframe;
   datetime          date;
   bool              on;
                     liq() {};

  };
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
setupTrades::setupTrades(const setupTrades& that)   // Copy
  {
   this.price = that.price;
   this.stop = that.stop;
   this.tp = that.tp;
   this.date = that.date;
   this.timeframe = that.timeframe;
   this.pos = that.pos;
   this.on = that.on;
   this.open = that.open;
   this.close = that.close;
   this.bartime = that.bartime;
  }
setupTrades trades[];
setupTrades trades1[];
setupTrades selltrades[];
setupTrades selltrades1[];
int c=1;
int posi;
double upFractals[];
double downFractals[];
double upTrades[];
double downTrades[];
double currentsellstop;
double currentbuystop;
bool buySignal = false;
bool sellSignal = false;
double spread = MarketInfo(Symbol(),MODE_SPREAD) * Point;
bool active = false;
liq upperLiquidity[];
liq lowerLiquidity[];
int startDay = 0;
int endDay = 5;
int starttime = 1;
int endtime = 22;
bool startEA = true;
int trend;
extern double Lots = 0.15;
double buyLots;
double sellLots;
extern bool followTrend = true;
extern double risk = 0.005;
extern double TrailingStop  = 100;
double priceoffset = 0;
double stopoffset = 0;
bool   FractalsUp        = False;
bool   FractalsDown      = False;
double FractalsUpPrice   = 0;
double FractalsDownPrice = 0;
int bars = 200;
double currentBuystop;
double currentSellstop;
double currentLots;
double prevstop;
double prevopen;
setupTrades filterB[];
setupTrades filterS[];

//if(OrderCommission() > 0){
//   double c = MathCeil(OrderCommission() / OrderLots())
//}

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
//const string k="key";
//const string u="1234";
//char data[];
//const string url = "https://us-central1-alpine-figure-293021.cloudfunctions.net/auth";
//
//bool request(const string  url,
//                         const string  method,
//                               char   &data[],
//                               string &response)
//{
//   if(IsTesting()) return(false);
//   
//   int    status_code;
//   string headers;
//   char   result[];
//   uint   timeout = GetTickCount();
//   
//   status_code = WebRequest(method, 
//                            url, 
//                            NULL, 
//                            NULL, 
//                            HTTP_TIMEOUT, 
//                            data, 
//                            ArraySize(data), 
//                            result, 
//                            headers);
//   
//   if(status_code == -1) {
//      if(GetTickCount() > timeout + HTTP_TIMEOUT) {
//         Print("WebRequest get timeout");
//      }
//      else {
//         Print(ErrorDescription(GetLastError()));
//      }
//      return(false);
//   }
//   
//   response = CharArrayToString(result, 0, ArraySize(result), CP_UTF8);
//   
//   return(true);
//}
//
//bool get(string url, string &response)
//{
//   char data[];
//   url+="?";
//      
//   url += "key";
//   url += "=";
//   url += "1234";
//
//   
//   return(request(url, "GET", data, response));
//}

bool turnOn()
  {
//Alert(DayOfWeek());
   if(Hour() >= starttime && Hour() < endtime && DayOfWeek() >= startDay && DayOfWeek() <= endDay)
     {
      return(true);
      //Alert("on");
     }
   else
      if(Hour() >= endtime || Hour() < starttime || DayOfWeek() < startDay)
        {
         delAllOrders();
         return(false);
         //Alert("off");
        }

   return(1);
  }
  
void turnOffWeekends() {

if(DayOfWeek() == 5 && Hour() >= 22){
   delAllOrders();
}

}

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void autoLots(int pips)
  {
//double risk = NormalizeDouble(AccountEquity() * 0.02,2);
   double risk =10000 * 0.02;
   double maxLots = ((AccountEquity() * AccountLeverage()) / 100000);
   maxLots = NormalizeDouble(maxLots,2);
   Lots = risk/pips;

  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void delAllOrders()
  {
   for(int i=OrdersTotal() - 1; i>=0; i--)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
         if(OrderSymbol()==Symbol() && OrderType()==OP_SELLSTOP)
           {
            if(!OrderDelete(OrderTicket()))
               Print("OrderSend error ",GetLastError());

           }
         else
            if(OrderSymbol()==Symbol() && OrderType()==OP_BUYSTOP)
              {
               if(!OrderDelete(OrderTicket()))
                  Print("OrderSend error ",GetLastError());
              }
            else
               if(OrderSymbol()==Symbol() && OrderType()==OP_BUY)
                 {
                  if(!OrderClose(OrderTicket(),OrderLots(),Bid,0,clrNONE))
                     Print("OrderSend error ",GetLastError());
                 }
               else
                  if(OrderSymbol()==Symbol() && OrderType()==OP_SELL)
                    {
                     if(!OrderClose(OrderTicket(),OrderLots(),Ask,0,clrNONE))
                        Print("OrderSend error ",GetLastError());
                    }
                  else
                     if(OrderSymbol()==Symbol() && OrderType()==OP_SELLLIMIT)
                       {
                        if(!OrderDelete(OrderTicket()))
                           Print("OrderSend error ",GetLastError());
                       }
                     else
                        if(OrderSymbol()==Symbol() && OrderType()==OP_BUYLIMIT)
                          {
                           if(!OrderDelete(OrderTicket()))
                              Print("OrderSend error ",GetLastError());
                          }
        }
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void closeBuyOrders()
  {
   for(int i=OrdersTotal() - 1; i>=0; i--)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
         if(OrderSymbol()==Symbol() && OrderType()==OP_BUY)
           {
            if(!OrderClose(OrderTicket(),Lots,Bid,0,clrNONE))
               Print("OrderSend error ",GetLastError());
           }
        }
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void closeSellOrders()
  {
   for(int i=OrdersTotal() - 1; i>=0; i--)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
         if(OrderSymbol()==Symbol() && OrderType()==OP_SELL)
           {
            if(!OrderClose(OrderTicket(),Lots,Ask,0,clrNONE))
               Print("OrderSend error ",GetLastError());
           }
        }
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool isNewCandle()
  {
   static datetime time0;
   if(Time[0] == time0)
      return false;
   else
      time0 = Time[0];
   return true;


  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void setupBuyTP()
  {
   for(int i=0; i<ArraySize(trades1); i++)
     {
      setupTrades bTP = closestTrade(selltrades1,trades1[i].price);
      if(bTP.price > trades1[i].price)
        {
         trades1[i].tp = bTP.price;
        }
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void setupSellTP()
  {
   for(int i=0; i<ArraySize(selltrades1); i++)
     {
      setupTrades sTP = closestTrade(trades1,selltrades1[i].price);
      if(sTP.price < selltrades1[i].price)
        {
         selltrades1[i].tp = sTP.price;
        }
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void TSLV2()
  {
//Alert(Symbol());
   for(int i=0; i<OrdersTotal(); i++)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
         //--- check for trailing stop
         if(OrderTicket() != EMPTY)
           {
            //Alert(OrderSymbol());
            //if(OrderSymbol() == Symbol()){
            if(OrderType() == OP_BUY)
              {
               double t = NormalizeDouble(((OrderTakeProfit() - OrderOpenPrice()) * .75), Digits);
               double buySL50 = NormalizeDouble(((OrderTakeProfit() - OrderOpenPrice()) * .50), Digits);
               //Alert(OrderTakeProfit() - OrderOpenPrice());
               //Alert(buySL50);
               if(Bid >= OrderOpenPrice() + t)
                 {
                  if(Bid > OrderOpenPrice() + buySL50)
                    {
                     if(!OrderModify(OrderTicket(),OrderOpenPrice(),OrderOpenPrice() + buySL50,OrderTakeProfit(),0,clrNONE))
                       {
                        Print("Cannot move stop up 50%");
                       }
                     else
                       {
                        string bm = "\n" + "SECURE 50% @" + DoubleToString(OrderStopLoss(), Digits);

                       }
                    }
                 }
              }
            if(OrderType() == OP_SELL)
              {
               double st = NormalizeDouble(((OrderOpenPrice() - OrderTakeProfit()) * .75), Digits);
               double sellSL50 = NormalizeDouble(((OrderOpenPrice() - OrderTakeProfit()) * .50), Digits);
               if(Ask <= OrderOpenPrice() - st)
                 {
                  if(Ask < OrderOpenPrice() - sellSL50)
                    {
                     if(!OrderModify(OrderTicket(),OrderOpenPrice(),OrderOpenPrice() - sellSL50,OrderTakeProfit(),0,clrNONE))
                       {
                        Print("Cannot move stop down 50%");
                       }
                     else
                       {
                        string sm = "\n" + "SECURE 50% @" + DoubleToString(OrderStopLoss(), Digits);

                       }
                    }
                 }
              }
            //}
           }
        }
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void TSL15()
  {
//Alert(Symbol());
   for(int i=0; i<OrdersTotal(); i++)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
         //--- check for trailing stop
         if(OrderTicket() != EMPTY)
           {
            //Alert(OrderSymbol());
            //if(OrderSymbol() == Symbol()){
            if(OrderType() == OP_BUY)
              {
               double t = NormalizeDouble(((OrderTakeProfit() - OrderOpenPrice()) * .75), Digits);
               double buySL15 = NormalizeDouble(((OrderTakeProfit() - OrderOpenPrice()) * .15), Digits);
               if(OrderStopLoss() > OrderOpenPrice() && Bid > OrderStopLoss() + buySL15)
                 {
                  if(!OrderModify(OrderTicket(),OrderOpenPrice(),OrderStopLoss() + buySL15,OrderTakeProfit(),0,clrNONE))
                    {
                     Print("Cannot move stop up");
                    }
                  else
                    {
                     string bm = "\n" + "SECURED @" + DoubleToString(OrderStopLoss(), Digits);

                    }
                 }
               //Alert(OrderTakeProfit() - OrderOpenPrice());
               //Alert(buySL50);
               if(Bid > OrderOpenPrice() + buySL15)
                 {
                  if(!OrderModify(OrderTicket(),OrderOpenPrice(),OrderOpenPrice() + buySL15,OrderTakeProfit(),0,clrNONE))
                    {
                     Print("Cannot move stop up");
                    }
                  else
                    {
                     string bm = "\n" + "SECURED @" + DoubleToString(OrderStopLoss(), Digits);

                    }
                 }

              }
            if(OrderType() == OP_SELL)
              {
               double st = NormalizeDouble(((OrderOpenPrice() - OrderTakeProfit()) * .75), Digits);
               double sellSL15 = NormalizeDouble(((OrderOpenPrice() - OrderTakeProfit()) * .15), Digits);
               if(OrderStopLoss() < OrderOpenPrice() && Ask < OrderStopLoss() - sellSL15)
                 {
                  if(!OrderModify(OrderTicket(),OrderOpenPrice(),OrderStopLoss() - sellSL15,OrderTakeProfit(),0,clrNONE))
                    {
                     Print("Cannot move stop down");
                    }
                  else
                    {
                     string sm = "\n" + "SECURED @" + DoubleToString(OrderStopLoss(), Digits);

                    }
                 }
               if(Ask < OrderOpenPrice() - sellSL15)
                 {
                  if(!OrderModify(OrderTicket(),OrderOpenPrice(),OrderOpenPrice() - sellSL15,OrderTakeProfit(),0,clrNONE))
                    {
                     Print("Cannot move stop down");
                    }
                  else
                    {
                     string sm = "\n" + "SECURED @" + DoubleToString(OrderStopLoss(), Digits);

                    }
                 }

              }
            //}
           }
        }
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void removeDuplicates(setupTrades &list[])
  {
   for(int i=0; i<ArraySize(list); i++)
     {
      for(int x=i+1; x<ArraySize(list); x++)
        {
         if(list[i].price == list[x].price)
           {
            deleteTrade(list,x);
           }
        }
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void removeDuplicates(liq &list[])
  {
   for(int i=0; i<ArraySize(list); i++)
     {
      for(int x=i+1; x<ArraySize(list); x++)
        {
         if(list[i].price == list[x].price)
           {
            deleteLiq(list,x);
           }
        }
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void trailingStop()
  {
   for(int i=0; i<OrdersTotal(); i++)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
         //--- check for trailing stop
         if(OrderTicket() != EMPTY && OrderMagicNumber() == 1)
           {
            if(OrderType() == OP_SELL)
              {
               if(OrderStopLoss() < OrderOpenPrice())
                 {
                  if(Ask < OrderStopLoss() - (Point*TrailingStop))
                    {
                     if(!OrderModify(OrderTicket(),OrderOpenPrice(),OrderStopLoss() - (Point*TrailingStop),OrderTakeProfit(),0,clrPurple))
                        //Print("OrderModify error ",GetLastError());
                        return;
                    }
                 }
               if(TrailingStop>0)
                 {
                  if((OrderOpenPrice() - Ask)>(Point*TrailingStop))
                    {
                     if(OrderStopLoss()>OrderOpenPrice())
                       {
                        currentsellstop = currentsellstop - (Point*TrailingStop);
                        //--- modify order and exit
                        if(!OrderModify(OrderTicket(),OrderOpenPrice(),OrderOpenPrice() - (Point*TrailingStop),OrderTakeProfit(),0,clrPurple))
                           //Print("OrderModify error ",GetLastError());
                           return;
                       }
                    }
                 }
              }
            else
               if(OrderType() == OP_BUY)
                 {
                  if(OrderStopLoss() > OrderOpenPrice())
                    {
                     if(Bid > OrderStopLoss() + (Point*TrailingStop))
                       {
                        if(!OrderModify(OrderTicket(),OrderOpenPrice(),OrderStopLoss() + (Point*TrailingStop),OrderTakeProfit(),0,clrPurple))
                           Print("OrderModify error ",GetLastError());
                        return;
                       }
                    }
                  if(TrailingStop>0)
                    {
                     if((Bid-OrderOpenPrice())>(Point*TrailingStop))
                       {
                        if(OrderStopLoss()<OrderOpenPrice())
                          {
                           //--- modify order and exit
                           if(!OrderModify(OrderTicket(),OrderOpenPrice(),OrderOpenPrice() + (Point*TrailingStop),OrderTakeProfit(),0,clrPurple))
                              Print("OrderModify error ",GetLastError());
                           return;
                          }
                       }
                    }
                 }
           }
        }
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void fib0()
  {

   int TF[]= {1440,240};
//liq temp;
   for(int x=0; x<2; x++)
     {
      FindFractals(TF[x]);
      //double down0[] = FindFractals(TF[x]);
      //(downFractals[ArraySize(downFractals)-1] < downFractals[ArraySize(downFractals)-2])
      if(upFractals[ArraySize(upFractals)-1] > upFractals[ArraySize(upFractals)-2])
        {
         trend = 0;
         //bull
        }
      else
         if(downFractals[ArraySize(downFractals)-1] < downFractals[ArraySize(downFractals)-2])
           {
            trend = 1;
            //bear
           }
         else
           {
            trend = 2;
           }
      switch(trend)
        {
         case 0:
           {
            for(int i=0; i < ArraySize(trades1); i++)
              {
               double currentfib = NormalizeDouble(upFractals[ArraySize(upFractals)-1] - (upFractals[ArraySize(upFractals)-1] - downFractals[ArraySize(downFractals)-1] * .618),Digits);
               if((trades1[i].price >= (currentfib - (currentfib *.0005))) && trades1[i].price <= (currentfib + (currentfib *.0005)))
                 {
                  trades1[i].on = true;
                  trades1[i].tp = upFractals[ArraySize(upFractals)-1];
                 }
               else
                 {
                  trades1[i].on = false;
                 }
              }
           }
         break;
         case 1:
           {
            for(int i=0; i < ArraySize(selltrades1); i++)
              {
               double currentfib = NormalizeDouble((upFractals[ArraySize(upFractals)-1] - downFractals[ArraySize(downFractals)-1] * .618) + downFractals[ArraySize(downFractals)-1],Digits);
               if((trades1[i].price >= (currentfib - (currentfib *.0005))) && (trades1[i].price <= (currentfib + (currentfib *.0005))))
                 {
                  selltrades1[i].on = true;
                  selltrades1[i].tp = downFractals[ArraySize(downFractals)-1];
                 }
               else
                 {
                  selltrades1[i].on = false;
                 }
              }
           }
         break;
         case 2:
           {

           }
         break;
        }
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int TotalOrders()
  {
   int x = 0;
   for(int i=0; i<OrdersTotal(); i++)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
         if(OrderSymbol()==Symbol())
           {
            x++;
           }
        }
     }
   return(x);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void closeExtras()
  {
   if(TotalOrders() > 1)
     {
      for(int i=0; i<OrdersTotal() - 1; i++)
        {
         if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
           {
            if(OrderSymbol()==Symbol())
              {
               OrderClose(OrderTicket(),OrderLots(),OrderOpenPrice(),0,clrNONE);
              }
           }
        }
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double closestTo(double &list[], double anchor)
  {
   int index = ArrayBsearch(list,anchor,WHOLE_ARRAY,0,MODE_ASCEND);
   return list[index];
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double closestSellTo(double &list[], double anchor)
  {
   int index = ArrayBsearch(list,anchor,WHOLE_ARRAY,0,MODE_ASCEND);
   return list[index];
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
setupTrades closestTrade(setupTrades &list[], double anchor)
  {
   double t[];
   for(int i=0; i<ArraySize(list); i++)
     {
      arrayPush(t,list[i].price);
     }
   int index = ArrayBsearch(t,anchor,WHOLE_ARRAY,0,MODE_ASCEND);
   list[index].on = true;
   return list[index];
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void FindFractals(int timeFrame)
  {
// ------------------------------------------(re)-Initialization of the variables
   FractalsUp        = False;
   FractalsDown      = False;
   FractalsUpPrice   = 0;
   FractalsDownPrice = 0;
   /* --------------------------------------A for(){...} loop to scan
                                                         the last FractalsLimit
                                                         candles, starting from
                                                         the oldest and finishing
                                                         with the most recent one */
   for(int i = bars; i >= 0; i--)
     {
      // ----------------------------------------------------------------------------
      double fu = iFractals(NULL, timeFrame, MODE_UPPER, i);
      double fl = iFractals(NULL, timeFrame, MODE_LOWER, i);
      /* If there is a POSACK of fractal on the candle
            the value will be greater than zero
            and equal to the highest or lowest price */
      // ---------------------------------------------------------------------------
      if(fu >  0)                         // If there is an upper fractal
        {
         FractalsUpPrice   = fu;
         arrayPush(upFractals,fu);       //    store the value and
         FractalsUp        = True;     //    set True the FractalsUp variable
         FractalsDown      = False;    //    set False on POSACK_UP
        }
      // ----------------------------------------------------------------------------
      if(fl >  0)                         // If there is an lower fractal
        {
         FractalsDownPrice = fl;
         arrayPush(downFractals,fl);       //    store the value and
         FractalsUp        = False;    //    set False on POSACK_LO
         FractalsDown      = True;     //    set True the FractalsDown variable
        }
      // ----------------------------------------------------------------------------
      if(fu >  0                          // If the candle has both upper
         && fl >  0                       //    and lower fractal
        )
        {
         FractalsUpPrice   = fu;       //    the values are stored
         FractalsDownPrice = fl;
         arrayPush(upFractals,fu);
         arrayPush(downFractals,fl);
         FractalsUp        = False;    //    but we do not, on NACK,
         FractalsDown      = False;    //    consider it as last fractal
        }
     }
  }

// Helper function to "push" to array
void arrayPush(double &array[], double dataToPush)
  {
   int count = ArrayResize(array, ArraySize(array) + 1);
   array[ArraySize(array) - 1] = dataToPush;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void tradePush(setupTrades &array[], setupTrades &dataToPush)
  {
   int count = ArrayResize(array, ArraySize(array) + 1);
   array[ArraySize(array) - 1] = dataToPush;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void liqPush(liq &array[], liq &dataToPush)
  {
   int count = ArrayResize(array, ArraySize(array) + 1);
   array[ArraySize(array) - 1] = dataToPush;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void Erase(double &A[], int iPos)
  {
   int iLast = ArraySize(A) - 1;
   A[iPos] = A[iLast];
   ArrayResize(A, iLast);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void deleteTrade(setupTrades &A[], int iPos)
  {
   int iLast = ArraySize(A) - 1;
   A[iPos] = A[iLast];
   ArrayResize(A, iLast);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void deleteLiq(liq &A[], int iPos)
  {
   int iLast = ArraySize(A) - 1;
   A[iPos] = A[iLast];
   ArrayResize(A, iLast);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double findFractal(int nbr, int mode, int timeframe)
  {
   int i=3, n;
   for(n=0; n<=nbr; n++)
     {
      while(iFractals(Symbol(),timeframe,mode,i) == 0)
         i++;
      if(n<nbr)
         i++;
     }
   return(iFractals(Symbol(),timeframe,mode,i));
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void signal()
  {
   if(iHigh(Symbol(),PERIOD_H1,c) > iHigh(Symbol(),PERIOD_H1,c-1) && iHigh(Symbol(),PERIOD_H1,c) > iHigh(Symbol(),PERIOD_H1,c+1))
     {
      sellSignal = true;
      buySignal = false;
      c = 1;
     }
   else
      if(iLow(Symbol(),PERIOD_H1,c) < iLow(Symbol(),PERIOD_H1,c-1) && iLow(Symbol(),PERIOD_H1,c) < iLow(Symbol(),PERIOD_H1,c+1))
        {
         buySignal = true;
         sellSignal = false;
         c = 1;
        }
      else
        {
         c = c + 1;
        }

  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void liquidity()
  {
   int TF[]= {240,60,15};
   liq temp;
   for(int x=0; x<3; x++)
     {

      int bars = 200;//iBars(Symbol(),TF[x]);
      FindFractals(TF[x]);
      double bullOB[];
      for(int i=bars;i>0;i--){
         for(int j=bars-1;j>0;j--){
            if(MathAbs(iLow(Symbol(),TF[x],i) - iLow(Symbol(),TF[x],j)) <= 10*Point){
               temp.price = iLow(Symbol(),TF[x],j);
               temp.timeframe = TF[x];
               temp.date=iTime(Symbol(),TF[x],j);
               temp.on = true;
               liqPush(lowerLiquidity,temp);
               //arrayPush(lowerLiquidity,iLow(Symbol(),TF[x],i));
            }
            if(MathAbs(iHigh(Symbol(),TF[x],i) - iHigh(Symbol(),TF[x],j)) <= 10*Point){
               temp.price = iHigh(Symbol(),TF[x],i);
               temp.timeframe = TF[x];
               temp.date=iTime(Symbol(),TF[x],j);
               temp.on = true;
               liqPush(upperLiquidity,temp);
               //arrayPush(upperLiquidity,iHigh(Symbol(),TF[x],i));
            }
         }
      }
     }

   for(int i=0; i<ArraySize(upperLiquidity); i++)
     {
      int shiftIndex = iBarShift(Symbol(),upperLiquidity[i].timeframe,upperLiquidity[i].date,false);
      for(int p=shiftIndex; p>0; p--)
        {
         if(iHigh(Symbol(),upperLiquidity[i].timeframe,p) >= upperLiquidity[i].price)
           {
            //deleteTrade(trades1,i);
            //deleteLiq(upperLiquidity,i);
            upperLiquidity[i].on = false;
           }
        }

     }

   for(int i=0; i<ArraySize(lowerLiquidity); i++)
     {
      int shiftIndex = iBarShift(Symbol(),lowerLiquidity[i].timeframe,lowerLiquidity[i].date,false);
      for(int p=shiftIndex; p>0; p--)
        {
         if(iLow(Symbol(),lowerLiquidity[i].timeframe,p) <= lowerLiquidity[i].price)
           {
            //deleteTrade(trades1,i);
            //deleteLiq(lowerLiquidity,i);
            lowerLiquidity[i].on = false;
           }
        }

     }

   removeDuplicates(upperLiquidity);
   removeDuplicates(lowerLiquidity);

   for(int i=0; i<ArraySize(upperLiquidity); i++)
     {
      for(int z=0; z<ArraySize(selltrades1); z++)
        {

         if(selltrades1[z].on == true && upperLiquidity[i].on == true && upperLiquidity[i].price >= selltrades1[z].stop)
           {
            selltrades1[z].on = false;
           }

        }
     }

   for(int i=0; i<ArraySize(lowerLiquidity); i++)
     {
      for(int z=0; z<ArraySize(trades1); z++)
        {

         if(trades1[z].on == true && lowerLiquidity[i].on == true && lowerLiquidity[i].price <= trades1[z].stop)
           {
            trades1[z].on = false;
           }

        }
     }
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void freshBullishOB()
  {
   int TF[]={1440,240,60};
//int x = 0;
   for(int x=0; x<3; x++)
     {
      setupTrades trade;
      //int bars = 50;//iBars(Symbol(),TF[x]);
      FindFractals(TF[x]);
      //double bullOB[];
      for(int i = bars; i>3; i--)
        {
         if(MathAbs(iHigh(Symbol(),TF[x],i) - iLow(Symbol(),TF[x],i)) != 0)
           {
            if(((MathAbs(iOpen(Symbol(),TF[x],i) - iClose(Symbol(),TF[x],i))) / (MathAbs(iHigh(Symbol(),TF[x],i) - iLow(Symbol(),TF[x],i)))) <= .63 
               && (iHigh(Symbol(),TF[x],i-1) >= iHigh(Symbol(), TF[x],i)) 
               && (iHigh(Symbol(),TF[x],i-2) >= iHigh(Symbol(), TF[x],i-1)) 
               && (iLow(Symbol(),TF[x],i) < iLow(Symbol(),TF[x],i-1)) && (iLow(Symbol(),TF[x],i-1) < iLow(Symbol(),TF[x],i-2))
               )
              {
               trade.price = iHigh(Symbol(),TF[x],i);
               trade.timeframe = TF[x];
               trade.date = iTime(Symbol(),TF[x],i);
               trade.stop = iLow(Symbol(),TF[x],i);
               //trade.stop = trade.price - (100 * Point);
               //trade.stop = iClose(Symbol(),TF[x],i);
               trade.tp = findFractal(0,MODE_UPPER,TF[x]);
               trade.pos = i;
               trade.on = true;
               trade.symb = Symbol();
               trade.open = iOpen(Symbol(),TF[x],i);
               trade.close = iClose(Symbol(),TF[x],i);
               tradePush(trades,trade);
               //arrayPush(bullOB,iHigh(Symbol(),TF[x],i));
              }
           }
        }
      //ArraySort(bullOB,WHOLE_ARRAY,0,MODE_DESCEND);

      //Send once a trade no duplicates - use iTime and iBarShift to filter non-touched order blocks
      for(int t=0; t<ArraySize(downFractals); t++)
        {
         removeDuplicates(trades1);
         setupTrades tr = closestTrade(trades,downFractals[t]);
         tradePush(trades1,tr);
         //Alert(tr.price);

        }
     }
   for(int i=0; i<ArraySize(trades1); i++)
     {
      if(trades1[i].price > Ask)
        {
         trades1[i].on = false;
        }
      if(Bid <= trades1[i].price && Bid >= trades1[i].stop)
        {
         trades1[i].on = false;
        }
     }
   for(int i=0; i<ArraySize(trades1); i++)
     {
      int shiftIndex = iBarShift(Symbol(),trades1[i].timeframe,trades1[i].date,false);
      for(int p=shiftIndex-2; p>0; p--)
        {
         if(iLow(Symbol(),trades1[i].timeframe,p) <= trades1[i].price)
           {
            //deleteTrade(trades1,i);
            trades1[i].on = false;
           }
        }

     }


   for(int i=OrdersHistoryTotal()-1; i>=0; i--)
     {
      if(OrderSelect(i, SELECT_BY_POS,MODE_HISTORY))
        {
         if(OrderSymbol()==Symbol())
           {
            if(OrderTicket() != EMPTY)
              {
               if(OrderType()==OP_BUY)
                 {
                  for(int z=0; z<ArraySize(trades1); z++)
                    {
                     if(OrderOpenPrice() <= trades1[z].price && OrderOpenPrice() > trades1[z].stop)
                       {
                        trades1[z].on = false;
                       }
                    }
                 }
              }
           }
        }
     }
     
//     for(int k=0; k<ArraySize(trades1); k++){
//      for(int g = iBarShift(NULL,240,trades1[k].bartime,true);g<iBarShift(NULL,240,trades1[k].bartime + 1440*60,true);g++){
//         if(MathAbs(iHigh(Symbol(),240,g) - iLow(Symbol(),240,g)) != 0)
//           {
//            if(((MathAbs(iOpen(Symbol(),240,g) - iClose(Symbol(),240,g))) / (MathAbs(iHigh(Symbol(),240,g) - iLow(Symbol(),240,g)))) <= .63 
//               && (iHigh(Symbol(),240,g-1) >= iHigh(Symbol(), 240,g)) 
//               && (iHigh(Symbol(),240,g-2) >= iHigh(Symbol(), 240,g-1)) 
//               && (iLow(Symbol(),240,g) < iLow(Symbol(),240,g-1)) && (iLow(Symbol(),240,g-1) < iLow(Symbol(),240,g-2))
//               )
//              {
//              
//              if(iHigh(Symbol(),240,g) <= trades1[k].open && iLow(Symbol(),240,g) >= trades1[k].close){
//              
//              for(int l = iBarShift(NULL,60,trades1[k].bartime,true);l<iBarShift(NULL,60,trades1[k].bartime + 1440*60,true);l++){
//              
//              if(MathAbs(iHigh(Symbol(),60,l) - iLow(Symbol(),60,l)) != 0)
//           {
//            if(((MathAbs(iOpen(Symbol(),60,l) - iClose(Symbol(),60,l))) / (MathAbs(iHigh(Symbol(),60,l) - iLow(Symbol(),60,l)))) <= .63 
//               && (iHigh(Symbol(),60,l-1) >= iHigh(Symbol(), 60,l)) 
//               && (iHigh(Symbol(),60,l-2) >= iHigh(Symbol(), 60,l-1)) 
//               && (iLow(Symbol(),60,l) < iLow(Symbol(),60,l-1)) && (iLow(Symbol(),60,l-1) < iLow(Symbol(),60,l-2))
//               )
//              {
//              
//              if(iHigh(Symbol(),60,l) <= trades1[k].open && iLow(Symbol(),60,l) >= trades1[k].close){
//              setupTrades trade;
//              trade.price = iHigh(Symbol(),60,l);
//               trade.timeframe = 60;
//               trade.date = iTime(Symbol(),60,l);
//               trade.stop = iLow(Symbol(),60,l);
//               //trade.stop = trade.price - (100 * Point);
//               //trade.stop = iClose(Symbol(),TF[x],i);
//               trade.tp = findFractal(0,MODE_UPPER,60);
//               trade.pos = l;
//               trade.on = true;
//               trade.symb = Symbol();
//               trade.open = iOpen(Symbol(),60,l);
//               trade.close = iClose(Symbol(),60,l);
//               tradePush(trades1,trade);
//              
//              }
//              
//              
//              
//              
//              }
//              }
//              }
//              
//              }
//              
//              
//              
//              }
//              }
//      
//      
//      }
//     }
     
     for(int k=0; k<ArraySize(trades1); k++){
   if(trades1[k].timeframe == 1440 && trades1[k].on == true){
      for(int j; j<ArraySize(trades1); j++){
         if(trades1[j].timeframe == 240 && trades1[j].on == true){
            if(trades1[j].open <= trades1[k].open && trades1[j].close == trades1[k].close){
               trades1[k].on = false;
               for(int u; u<ArraySize(trades1); u++){
                  if(trades1[u].timeframe == 60 && trades1[u].on == true){
                     if(trades1[u].open <= trades1[j].open && trades1[u].close == trades1[j].close){
                     trades1[j].on = false;
                     tradePush(filterB, trades1[u]);
                     
                     }
                  }
               
               }
            
            }
         
         }
      }
   }
  }
  
//  for(int k=0; k<ArraySize(trades1); k++){
//   if(trades1[k].timeframe == 240 && trades1[k].on == true){
//      for(int j; j<ArraySize(trades1); j++){
//         if(trades1[j].timeframe == 60 && trades1[j].on == true){
//            if(trades1[j].open <= trades1[k].open && trades1[j].close == trades1[k].close){
//               //trades1[k].on = false;
//               for(int u; u<ArraySize(trades1); u++){
//                  if(trades1[u].timeframe == 15 && trades1[u].on == true){
//                     if(trades1[u].open <= trades1[j].open && trades1[u].close == trades1[j].close){
//                     //trades1[j].on = false;
//                     tradePush(filterB, trades1[u]);
//                     
//                     }
//                  }
//               
//               }
//            
//            }
//         
//         }
//      }
//   }
//  }
//  
//  for(int k=0; k<ArraySize(trades1); k++){
//   if(trades1[k].timeframe == 60 && trades1[k].on == true){
//      for(int j; j<ArraySize(trades1); j++){
//         if(trades1[j].timeframe == 15 && trades1[j].on == true){
//            if(trades1[j].open <= trades1[k].open && trades1[j].close == trades1[k].close){
//               //trades1[k].on = false;
//               for(int u; u<ArraySize(trades1); u++){
//                  if(trades1[u].timeframe == 5 && trades1[u].on == true){
//                     if(trades1[u].open <= trades1[j].open && trades1[u].close == trades1[j].close){
//                     //trades1[j].on = false;
//                     tradePush(filterB, trades1[u]);
//                     
//                     }
//                  }
//               
//               }
//            
//            }
//         
//         }
//      }
//   }
//  }
     
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void freshBearishOB()
  {
   int TF[]={1440,240,60};
   //int TF[]= {60};
//int x = 0;
   for(int x=0; x<3; x++)
     {
      setupTrades strade;
      //int bars = 50;//iBars(Symbol(),TF[x]);
      FindFractals(TF[x]);
      //double bullOB[];
      for(int i = bars; i>3; i--)
        {
         if(MathAbs(iHigh(Symbol(),TF[x],i) - iLow(Symbol(),TF[x],i)) != 0)
           {
            if(((MathAbs(iOpen(Symbol(),TF[x],i) - iClose(Symbol(),TF[x],i))) / (MathAbs(iHigh(Symbol(),TF[x],i) - iLow(Symbol(),TF[x],i)))) <= .63 
               && (iLow(Symbol(),TF[x],i-1) <= iLow(Symbol(), TF[x],i)) && (iLow(Symbol(),TF[x],i-2) <= iLow(Symbol(), TF[x],i-1)) 
               && (iHigh(Symbol(),TF[x],i) > iHigh(Symbol(),TF[x],i-1)) && (iHigh(Symbol(),TF[x],i-1) > iHigh(Symbol(),TF[x],i-2))
               )
              {
              
//              for(int g = iBarShift(NULL,TF[x+1],iTime(NULL,TF[x],i),true);g<iBarShift(NULL,TF[x+1],iTime(NULL,TF[x],i)+TF[x]*60,true);g++){
//               if(MathAbs(iHigh(Symbol(),TF[x+1],g) - iLow(Symbol(),TF[x+1],g)) != 0) {
//            if(((MathAbs(iOpen(Symbol(),TF[x+1],g) - iClose(Symbol(),TF[x+1],g))) / (MathAbs(iHigh(Symbol(),TF[x+1],g) - iLow(Symbol(),TF[x+1],g)))) <= .63 
//               && (iLow(Symbol(),TF[x+1],g-1) <= iLow(Symbol(), TF[x+1],g)) && (iLow(Symbol(),TF[x+1],g-2) <= iLow(Symbol(), TF[x+1],g-1)) 
//               && (iHigh(Symbol(),TF[x+1],g) > iHigh(Symbol(),TF[x+1],g-1)) && (iHigh(Symbol(),TF[x+1],g-1) > iHigh(Symbol(),TF[x+1],g-2))
//               ) {
//                  
//              
//              }
//           }
//        }
               strade.price = iLow(Symbol(),TF[x],i);
               strade.timeframe = TF[x];
               strade.date = iTime(Symbol(),TF[x],i);
               strade.stop = iHigh(Symbol(),TF[x],i);
               //strade.stop = strade.price + (100 * Point);
               //strade.stop = iClose(Symbol(),TF[x],i);
               strade.tp = findFractal(0,MODE_LOWER,TF[x]);
               strade.pos = i;
               strade.on = true;
               strade.symb = Symbol();
               strade.open = iOpen(Symbol(),TF[x],i);
               strade.close = iClose(Symbol(),TF[x],i);
               tradePush(selltrades,strade);
               //arrayPush(bullOB,iHigh(Symbol(),TF[x],i));
              }
           }
        }
      //ArraySort(bullOB,WHOLE_ARRAY,0,MODE_DESCEND);

      //Send once a trade no duplicates - use iTime and iBarShift to filter non-touched order blocks
      for(int t=0; t<ArraySize(upFractals); t++)
        {
         removeDuplicates(selltrades1);
         setupTrades str = closestTrade(selltrades,upFractals[t]);
         tradePush(selltrades1,str);
         //Alert(tr.price);

        }
     }

   for(int i=0; i<ArraySize(selltrades1); i++)
     {
      if(selltrades1[i].price < Bid)
        {
         selltrades1[i].on = false;
        }
      if(Ask >= selltrades1[i].price && Ask <= selltrades1[i].stop)
        {
         selltrades1[i].on = false;
        }
     }
   for(int i=0; i<ArraySize(selltrades1); i++)
     {
      int shiftIndex = iBarShift(Symbol(),selltrades1[i].timeframe,selltrades1[i].date,false);
      for(int p=shiftIndex-2; p>0; p--)
        {
         if(iHigh(Symbol(),selltrades1[i].timeframe,p) >= selltrades1[i].price)
           {
            //deleteTrade(trades1,i);
            selltrades1[i].on = false;
           }
        }

     }

   for(int i=OrdersHistoryTotal()-1; i>=0; i--)
     {
      if(OrderSelect(i, SELECT_BY_POS,MODE_HISTORY))
        {
         if(OrderSymbol()==Symbol())
           {
            if(OrderTicket() != EMPTY)
              {
               if(OrderType()==OP_SELL)
                 {
                  for(int z=0; z<ArraySize(selltrades1); z++)
                    {
                     if(OrderOpenPrice() >= selltrades1[z].price && OrderOpenPrice() < selltrades1[z].stop)
                       {
                        selltrades1[z].on = false;
                       }
                    }
                 }
              }
           }
        }
     }
     
//          for(int k=0; k<ArraySize(selltrades1); k++){
//      for(int g = iBarShift(NULL,240,selltrades1[k].bartime,true);g<iBarShift(NULL,240,selltrades1[k].bartime + 1440*60,true);g++){
//         if(MathAbs(iHigh(Symbol(),240,g) - iLow(Symbol(),240,g)) != 0)
//           {
//            if(((MathAbs(iOpen(Symbol(),240,g) - iClose(Symbol(),240,g))) / (MathAbs(iHigh(Symbol(),240,g) - iLow(Symbol(),240,g)))) <= .63 
//               && (iLow(Symbol(),240,g-1) <= iLow(Symbol(), 240,g)) && (iLow(Symbol(),240,g-2) <= iLow(Symbol(), 240,g-1)) 
//               && (iHigh(Symbol(),240,g) > iHigh(Symbol(),240,g-1)) && (iHigh(Symbol(),240,g-1) > iHigh(Symbol(),240,g-2))
//               )
//              {
//              
//              if(iLow(Symbol(),240,g) >= selltrades1[k].open && iLow(Symbol(),240,g) >= selltrades1[k].close){
//              
//              for(int l = iBarShift(NULL,60,selltrades1[k].bartime,true);l<iBarShift(NULL,60,selltrades1[k].bartime + 1440*60,true);l++){
//              
//              if(MathAbs(iHigh(Symbol(),60,l) - iLow(Symbol(),60,l)) != 0)
//           {
//            if(((MathAbs(iOpen(Symbol(),60,l) - iClose(Symbol(),60,l))) / (MathAbs(iHigh(Symbol(),60,l) - iLow(Symbol(),60,l)))) <= .63 
//               && (iLow(Symbol(),60,l-1) <= iLow(Symbol(), 60,l)) && (iLow(Symbol(),60,l-2) <= iLow(Symbol(), 60,l-1)) 
//               && (iHigh(Symbol(),60,l) > iHigh(Symbol(),60,l-1)) && (iHigh(Symbol(),60,l-1) > iHigh(Symbol(),60,l-2))
//               )
//              {
//              
//              if(iLow(Symbol(),60,l) >= selltrades1[k].open && iHigh(Symbol(),60,l) <= selltrades1[k].close){
//               setupTrades strade;
//               strade.price = iLow(Symbol(),60,l);
//               strade.timeframe = 60;
//               strade.date = iTime(Symbol(),60,l);
//               strade.stop = iHigh(Symbol(),60,l);
//               //strade.stop = strade.price + (100 * Point);
//               //strade.stop = iClose(Symbol(),TF[x],i);
//               strade.tp = findFractal(0,MODE_LOWER,60);
//               strade.pos = l;
//               strade.on = true;
//               strade.symb = Symbol();
//               strade.open = iOpen(Symbol(),60,l);
//               strade.close = iClose(Symbol(),60,l);
//               tradePush(selltrades1,strade);
//              
//              }
//              
//              
//              
//              
//              }
//              }
//              }
//              
//              }
//              
//              
//              
//              }
//              }
//      
//      
//      }
//     }
     
          for(int k=0; k<ArraySize(selltrades1); k++){
   if(selltrades1[k].timeframe == 1440 && selltrades1[k].on == true){
      for(int j; j<ArraySize(selltrades1); j++){
         if(selltrades1[j].timeframe == 240 && selltrades1[j].on == true){
            if(selltrades1[j].open <= selltrades1[k].open && selltrades1[j].close == selltrades1[k].close){
            selltrades1[k].on = false;
               for(int u; u<ArraySize(selltrades1); u++){
                  if(selltrades1[u].timeframe == 60 && selltrades1[u].on == true){
                     if(selltrades1[u].open <= selltrades1[j].open && selltrades1[u].close == selltrades1[j].close){
                     selltrades1[j].on = false;
                     tradePush(filterS, selltrades1[u]);
                     
                     }
                  }
               
               }
            
            }
         
         }
      }
   }
  }
  
//  for(int k=0; k<ArraySize(selltrades1); k++){
//   if(selltrades1[k].timeframe == 240  && selltrades1[k].on == true){
//      for(int j; j<ArraySize(selltrades1); j++){
//         if(selltrades1[j].timeframe == 60  && selltrades1[j].on == true){
//            if(selltrades1[j].open <= selltrades1[k].open && selltrades1[j].close == selltrades1[k].close){
//               //selltrades1[k].on = false;
//               for(int u; u<ArraySize(selltrades1); u++){
//                  if(selltrades1[u].timeframe == 15  && selltrades1[u].on == true){
//                     if(selltrades1[u].open <= selltrades1[j].open && selltrades1[u].close == selltrades1[j].close){
//                     //selltrades1[j].on = false;
//                     
//                     tradePush(filterS, selltrades1[u]);
//                     
//                     }
//                  }
//               
//               }
//            
//            }
//         
//         }
//      }
//   }
//  }
//  
//  for(int k=0; k<ArraySize(selltrades1); k++){
//   if(selltrades1[k].timeframe == 60  && selltrades1[k].on == true){
//      for(int j; j<ArraySize(selltrades1); j++){
//         if(selltrades1[j].timeframe == 15  && selltrades1[j].on == true){
//            if(selltrades1[j].open <= selltrades1[k].open && selltrades1[j].close == selltrades1[k].close){
//               for(int u; u<ArraySize(selltrades1); u++){
//                  if(selltrades1[u].timeframe == 5  && selltrades1[u].on == true){
//                     if(selltrades1[u].open <= selltrades1[j].open && selltrades1[u].close == selltrades1[j].close){
//                     
//                     tradePush(filterS, selltrades1[u]);
//                     
//                     }
//                  }
//               
//               }
//            
//            }
//         
//         }
//      }
//   }
//  }
  
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void setupTP()
  {
   for(int i=0; i<OrdersTotal(); i++)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
         //--- check for trailing stop
         if(OrderTicket() != EMPTY)
           {
            if(OrderType() == OP_SELL)
              {

               if(OrderTakeProfit() == 0)
                 {
                  double b[];
                  for(int z=0; z<ArraySize(trades1); z++)
                    {
                     if(trades1[z].on == true)
                       {
                        arrayPush(b,selltrades1[z].price);
                       }
                    }
                  //Print(b);

                  if(ArraySize(b) > 0)
                    {
                     if(OrderOpenPrice() > closestTo(b,OrderOpenPrice()))
                       {
                        double tp = closestTo(b,OrderOpenPrice());
                        OrderModify(OrderTicket(),OrderOpenPrice(),OrderStopLoss(),tp,0,clrNONE);
                       }
                    }


                 }
              }
            if(OrderType() == OP_BUY)
              {

               if(OrderTakeProfit() == 0)
                 {
                  double s[];
                  for(int z=0; z<ArraySize(selltrades1); z++)
                    {
                     if(selltrades1[z].on == true)
                       {
                        arrayPush(s,selltrades1[z].price);
                       }
                    }
                  //Print(b);

                  if(ArraySize(s) > 0)
                    {
                     if(OrderOpenPrice() > closestTo(s,OrderOpenPrice()))
                       {
                        double tp = closestTo(s,OrderOpenPrice());
                        OrderModify(OrderTicket(),OrderOpenPrice(),OrderStopLoss(),tp,0,clrNONE);
                       }
                    }


                 }
              }

           }

        }
     }

  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void avoidDoubleTrouble()
  {
//HEDGE FAILING POSITIONS (CUSTOM TRAILING STOP FOR HOW MUCH WAS LOST)


   for(int z=0; z<ArraySize(trades1); z++)
     {



      if(Bid <= trades1[z].close)
        {
         //OrderClose(OrderTicket(),OrderLots(),OrderOpenPrice(),0,clrNONE);
         if(TotalHedgeOrders() < 1 && TotalSellOrders() < 1 && TotalBuyOrders() < 1)
           {
            RefreshRates();
            OrderSend(Symbol(),OP_SELL,Lots,Bid,0,trades1[z].open,trades1[z].stop - (trades1[z].price - trades1[z].close),NULL,1,0,clrNONE);
            trades1[z].on = false;
           }
        }



     }


   for(int z=0; z<ArraySize(selltrades1); z++)
     {



      if(Ask >= selltrades1[z].close)
        {
         //OrderClose(OrderTicket(),OrderLots(),OrderOpenPrice(),0,clrNONE);
         if(TotalHedgeOrders() < 1 && TotalBuyOrders() < 1 && TotalSellOrders() < 1)
           {
            RefreshRates();
            OrderSend(Symbol(),OP_BUY,Lots,Ask,0,selltrades1[z].open,selltrades1[z].stop + (selltrades1[z].close - selltrades1[z].price),NULL,1,0,clrNONE);
            selltrades1[z].on = false;
           }
        }



     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double direction()
  {
   double y2 = iMACD(Symbol(),PERIOD_H4,5,35,5,PRICE_CLOSE,MODE_MAIN,0);
   double y1 = iMACD(Symbol(),PERIOD_H4,5,35,5,PRICE_CLOSE,MODE_MAIN,1);
   return(y2-y1);
//if + trend up, if - trend down
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void autoLots()
  {
   double maxLots = NormalizeDouble(((AccountEquity() * AccountLeverage() * 0.1) / 100000),2);
   double max = 10;
   if(Lots < max)
     {
      Lots=maxLots;
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void betSizing()
  {
   if(followTrend)
     {
      if(direction() > 0)
        {
         buyLots = Lots;
         sellLots = Lots/2;
        }
      else
         if(direction() < 0)
           {
            buyLots = Lots/2;
            sellLots = Lots;
           }
     }
   else
     {
      buyLots = Lots;
      sellLots = Lots;
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void hedgeTrigger()
  {
   for(int n=OrdersHistoryTotal()-1; n>=0; n--)        //Search history
     {
      if(!OrderSelect(n,SELECT_BY_POS,MODE_HISTORY))
         continue;
      if(OrderSymbol()==Symbol() && OrderMagicNumber()==0)
         if(TimeCurrent()-OrderCloseTime()==0)      //When order closes
           {
            if(OrderType()==OP_BUY && OrderClosePrice()<=OrderOpenPrice() && TotalHedgeOrders() < 1 && TotalSellOrders() < 1 && TotalBuyOrders() < 1)  //If buy order and close was less than open --> stop loss
              {
               OrderSend(Symbol(),OP_SELL,OrderLots()*2,Bid,100,OrderOpenPrice(),OrderClosePrice() - ((((OrderOpenPrice() - OrderClosePrice())/Point)/2)*Point) + (MarketInfo(Symbol(),MODE_SPREAD) * Point),NULL,1,0,clrNONE);
              }

            else
               if(OrderType()==OP_SELL && OrderClosePrice()>=OrderOpenPrice() && TotalHedgeOrders() < 1 && TotalBuyOrders() < 1 && TotalBuyOrders() < 1)    //If sell order and close was greater than open --> stop loss
                 {
                  OrderSend(Symbol(),OP_BUY,OrderLots()*2,Ask,100,OrderOpenPrice(),OrderClosePrice() + ((((OrderClosePrice() - OrderOpenPrice())/Point)/2)*Point) + (MarketInfo(Symbol(),MODE_SPREAD) * Point),NULL,1,0,clrNONE);
                 }
           }
     }
  }
  
  void hedgeTrigger2()
  {
   for(int n=OrdersHistoryTotal()-1; n>=0; n--)        //Search history
     {
      if(!OrderSelect(n,SELECT_BY_POS,MODE_HISTORY))
         continue;
      if(OrderSymbol()==Symbol() && OrderMagicNumber()==1)
         continue;
         if(OrderTicket() != EMPTY)
            continue;
         if(TimeCurrent()-OrderCloseTime()==0)      //When order closes at a loss
           {
           //buy at double the risk and take profit at half the loss = full recovery
            if(OrderType()==OP_BUY && OrderClosePrice()<=OrderOpenPrice() && TotalHedgeOrders() < 1 && TotalSellOrders() < 1 && TotalBuyOrders() < 1)  //If buy order and close was less than open --> stop loss
              {
               OrderSend(Symbol(),OP_BUY,OrderLots()*2,Ask,100,0,OrderOpenPrice() - ((((OrderOpenPrice() - OrderClosePrice())/Point)/2)*Point) + (MarketInfo(Symbol(),MODE_SPREAD) * Point),NULL,2,0,clrNONE);
              }

            else
            //buy at double the risk and take profit at half the loss = full recovery
               if(OrderType()==OP_SELL && OrderClosePrice()>=OrderOpenPrice() && TotalHedgeOrders() < 1 && TotalBuyOrders() < 1 && TotalBuyOrders() < 1)    //If sell order and close was greater than open --> stop loss
                 {
                  OrderSend(Symbol(),OP_SELL,OrderLots()*2,Bid,100,0,OrderOpenPrice() + ((((OrderClosePrice() - OrderOpenPrice())/Point)/2)*Point) + (MarketInfo(Symbol(),MODE_SPREAD) * Point),NULL,2,0,clrNONE);
                 }
           }
     }
  }
  
    void hedgeTrigger3()
  {
   for(int n=OrdersHistoryTotal()-1; n>=0; n--)        //Search history
     {
      if(!OrderSelect(n,SELECT_BY_POS,MODE_HISTORY))
         continue;
      if(OrderSymbol()==Symbol() && OrderMagicNumber()==1)
         if(TimeCurrent()-OrderCloseTime()==0)      //When order closes at a loss
           {
           //buy at double the risk and take profit at half the loss = full recovery
            if(OrderType()==OP_BUY && OrderClosePrice()<=OrderOpenPrice() && TotalHedgeOrders() < 1 && TotalSellOrders() < 1 && TotalBuyOrders() < 1)  //If buy order and close was less than open --> stop loss
              {
               OrderSend(Symbol(),OP_BUY,0.30,Ask,500,Ask - ((300*Point) - MarketInfo(Symbol(),MODE_SPREAD)*Point),Ask + NormalizeDouble(((MathAbs(OrderOpenPrice() - OrderClosePrice()))/2) + (MarketInfo(Symbol(),MODE_SPREAD) * Point),5),NULL,2,0,clrNONE);
              }

            else
            //buy at double the risk and take profit at half the loss = full recovery
               if(OrderType()==OP_SELL && OrderClosePrice()>=OrderOpenPrice() && TotalHedgeOrders() < 1 && TotalBuyOrders() < 1 && TotalSellOrders() < 1)    //If sell order and close was greater than open --> stop loss
                 {
                  OrderSend(Symbol(),OP_SELL,0.30,Bid + ((300*Point) - MarketInfo(Symbol(),MODE_SPREAD)*Point),500,0,Bid + NormalizeDouble(((MathAbs(OrderClosePrice() - OrderOpenPrice()))/2) + (MarketInfo(Symbol(),MODE_SPREAD) * Point),5),NULL,2,0,clrNONE);
                 }
           }
     }
  }
  
  
  
  void test1(){
   if((iClose(Symbol(),PERIOD_D1,1) - iOpen(Symbol(),PERIOD_D1,1)) > 0){
      buySignal = true;
      sellSignal = false;
   } else if((iClose(Symbol(),PERIOD_D1,1) - iOpen(Symbol(),PERIOD_D1,1)) < 0){
      sellSignal = true;
      buySignal = false;
   } else {
      buySignal = false;
      sellSignal = false;
   }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int TotalBuyOrders()
  {
   int x = 0;
   for(int i=0; i<OrdersTotal(); i++)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
         if(OrderSymbol()==Symbol())
           {
            if(OrderType() == OP_BUY)
              {
               x++;
              }
           }
        }
     }
   return(x);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int TotalSellOrders()
  {
   int x = 0;
   for(int i=0; i<OrdersTotal(); i++)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
         if(OrderSymbol()==Symbol())
           {
            if(OrderType() == OP_SELL)
              {
               x++;
              }
           }
        }
     }
   return(x);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int TotalHedgeOrders()
  {
   datetime BOD = Time[0] - Time[0] % 86400;
   int x = 0;
   for(int i=0; i<OrdersTotal(); i++)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
         if(OrderSymbol()==Symbol() && OrderMagicNumber() == 2 && OrderCloseTime() > BOD)
           {

            x++;

           }
        }
     }
   return(x);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int todayOrdersTotal()
  {
   datetime    BOD     = Time[0] - Time[0] % 86400;    // Beginning of today
// Use  = TimeCurrent() - 86400 for last 24 hours
   int         count   = 0;
   for(int pos=OrdersHistoryTotal()-1; pos >= 0; pos--)
      if(
         OrderSelect(pos, SELECT_BY_POS, MODE_HISTORY)   // Only orders w/
         && OrderMagicNumber()   == 1
         &&  OrderSymbol()       == Symbol()                 // my pair,
         &&  OrderCloseTime()    > BOD                       // closed today.
         &&  OrderType()         <= OP_SELL) // Avoid cr/bal https://www.mql5.com/en/forum/126192
        {
         count++;
        }
   return (count);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void stoplossHit()
  {
   for(int p=0; p < OrdersTotal(); p++)
     {
      if(OrderSelect(p,SELECT_BY_POS,MODE_TRADES))
        {
         if(OrderSymbol() == Symbol() && OrderTicket() != EMPTY)
           {
            if(OrderType() == OP_BUY)
              {
               if(Ask <= currentbuystop)
                 {
                  OrderClose(OrderTicket(),Lots,Ask,0,clrNONE);
                 }
              }
            else
               if(OrderType() == OP_SELL)
                 {
                  if(Bid >= currentsellstop)
                    {
                     OrderClose(OrderTicket(),Lots,Bid,0,clrNONE);
                    }
                 }
           }
        }
     }
  }
  
void fractalStopLoss() {

   for(int p=0; p < OrdersTotal(); p++)
     {
      if(OrderSelect(p,SELECT_BY_POS,MODE_TRADES))
        {
         if(OrderSymbol() == Symbol() && OrderTicket() != EMPTY)
           {
            if(OrderType() == OP_BUY)
              {
              
              switch (OrderMagicNumber()) {
               
               case 5:
               
                  for(int j=3; j<Bars; j++) {
    if(iFractals(Symbol(),1,MODE_LOWER,j)!=0) {
      if(iFractals(Symbol(),1,MODE_LOWER,j) > OrderOpenPrice()){
         OrderModify(OrderTicket(),OrderOpenPrice(),iFractals(Symbol(),5,MODE_LOWER,j),OrderTakeProfit(),0,clrNONE);
         //Alert("Lower fractal found at bar ",j) ;
         break;
         }
         }

    if(iFractals(Symbol(),1,MODE_UPPER,j)!=0) {
      if(iFractals(Symbol(),1,MODE_UPPER,j) > OrderOpenPrice()){
         //OrderClose(OrderTicket(),OrderLots(),Bid,0,clrNONE);
         //Alert("Upper fractal found at bar ",j) ;
         break;
         }
         }
    }
    
    break;
    
    case 15:
               
                  for(int j=3; j<Bars; j++) {
    if(iFractals(Symbol(),5,MODE_LOWER,j)!=0) {
      if(iFractals(Symbol(),5,MODE_LOWER,j) > OrderOpenPrice()){
         OrderModify(OrderTicket(),OrderOpenPrice(),iFractals(Symbol(),5,MODE_LOWER,j),OrderTakeProfit(),0,clrNONE);
         //Alert("Lower fractal found at bar ",j) ;
         break;
         }
         }

    if(iFractals(Symbol(),5,MODE_UPPER,j)!=0) {
      if(iFractals(Symbol(),5,MODE_UPPER,j) > OrderOpenPrice()){
         //OrderClose(OrderTicket(),OrderLots(),Bid,0,clrNONE);
         //Alert("Upper fractal found at bar ",j) ;
         break;
         }
         }
    }
    
    break;
    
    case 60:
               
                  for(int j=3; j<Bars; j++) {
    if(iFractals(Symbol(),15,MODE_LOWER,j)!=0) {
      if(iFractals(Symbol(),15,MODE_LOWER,j) > OrderOpenPrice()){
         OrderModify(OrderTicket(),OrderOpenPrice(),iFractals(Symbol(),15,MODE_LOWER,j),OrderTakeProfit(),0,clrNONE);
         //Alert("Lower fractal found at bar ",j) ;
         break;
         }
         }

    if(iFractals(Symbol(),15,MODE_UPPER,j)!=0) {
      if(iFractals(Symbol(),15,MODE_UPPER,j) > OrderOpenPrice()){
         //OrderClose(OrderTicket(),OrderLots(),Bid,0,clrNONE);
         //Alert("Upper fractal found at bar ",j) ;
         break;
         }
         }
    }
    
    break;
    
    case 240:
               
                  for(int j=3; j<Bars; j++) {
    if(iFractals(Symbol(),60,MODE_LOWER,j)!=0) {
      if(iFractals(Symbol(),60,MODE_LOWER,j) > OrderOpenPrice()){
         OrderModify(OrderTicket(),OrderOpenPrice(),iFractals(Symbol(),60,MODE_LOWER,j),OrderTakeProfit(),0,clrNONE);
         //Alert("Lower fractal found at bar ",j) ;
         break;
         }
         }

    if(iFractals(Symbol(),60,MODE_UPPER,j)!=0) {
      if(iFractals(Symbol(),60,MODE_UPPER,j) > OrderOpenPrice()){
         //OrderClose(OrderTicket(),OrderLots(),Bid,0,clrNONE);
         //Alert("Upper fractal found at bar ",j) ;
         break;
         }
         }
    }
    
    break;
    
    case 1440:
               
                  for(int j=3; j<Bars; j++) {
    if(iFractals(Symbol(),240,MODE_LOWER,j)!=0) {
      if(iFractals(Symbol(),240,MODE_LOWER,j) > OrderOpenPrice()){
         //OrderModify(OrderTicket(),OrderOpenPrice(),iFractals(Symbol(),240,MODE_LOWER,j),OrderTakeProfit(),0,clrNONE);
         //Alert("Lower fractal found at bar ",j) ;
         break;
         }
         }

    if(iFractals(Symbol(),240,MODE_UPPER,j)!=0) {
      if(iFractals(Symbol(),240,MODE_UPPER,j) > OrderOpenPrice()){
         //OrderClose(OrderTicket(),OrderLots(),Bid,0,clrNONE);
         //Alert("Upper fractal found at bar ",j) ;
         break;
         }
         }
    }
    
    break;
    
    
              
              
              }
              
              }
            else
               if(OrderType() == OP_SELL)
                 {
                  switch (OrderMagicNumber()) {
               
               case 5:
               
                  for(int j=3; j<Bars; j++) {
    if(iFractals(Symbol(),5,MODE_LOWER,j)!=0) {
         OrderClose(OrderTicket(),OrderLots(),Ask,0,clrNONE);
         //Alert("Lower fractal found at bar ",j) ;
         break;
         }

    if(iFractals(Symbol(),5,MODE_UPPER,j)!=0) {
         OrderModify(OrderTicket(),OrderOpenPrice(),iFractals(Symbol(),5,MODE_UPPER,j),OrderTakeProfit(),0,clrNONE);
         //Alert("Upper fractal found at bar ",j) ;
         break;
         }
    }
    
    break;
    
    case 15:
               
                  for(int j=3; j<Bars; j++) {
    if(iFractals(Symbol(),15,MODE_LOWER,j)!=0) {
         OrderClose(OrderTicket(),OrderLots(),Ask,0,clrNONE);
         //Alert("Lower fractal found at bar ",j) ;
         break;
         }

    if(iFractals(Symbol(),15,MODE_UPPER,j)!=0) {
         OrderModify(OrderTicket(),OrderOpenPrice(),iFractals(Symbol(),15,MODE_UPPER,j),OrderTakeProfit(),0,clrNONE);
         //Alert("Upper fractal found at bar ",j) ;
         break;
         }
    }
    
    break;
    
    case 60:
               
                  for(int j=0; j<Bars; j++) {
    if(iFractals(Symbol(),60,MODE_LOWER,j)!=0) {
         OrderClose(OrderTicket(),OrderLots(),Ask,0,clrNONE);
         //Alert("Lower fractal found at bar ",j) ;
         break;
         }

    if(iFractals(Symbol(),60,MODE_UPPER,j)!=0) {
         OrderModify(OrderTicket(),OrderOpenPrice(),iFractals(Symbol(),60,MODE_UPPER,j),OrderTakeProfit(),0,clrNONE);
         //Alert("Upper fractal found at bar ",j) ;
         break;
         }
    }
    
    break;
    
    case 240:
               
                  for(int j=0; j<Bars; j++) {
    if(iFractals(Symbol(),240,MODE_LOWER,j)!=0) {
         OrderClose(OrderTicket(),OrderLots(),Ask,0,clrNONE);
         //Alert("Lower fractal found at bar ",j) ;
         break;
         }

    if(iFractals(Symbol(),240,MODE_UPPER,j)!=0) {
         OrderModify(OrderTicket(),OrderOpenPrice(),iFractals(Symbol(),240,MODE_UPPER,j),OrderTakeProfit(),0,clrNONE);
         //Alert("Upper fractal found at bar ",j) ;
         break;
         }
    }
    
    break;
    
    case 1440:
               
                  for(int j=0; j<Bars; j++) {
    if(iFractals(Symbol(),1440,MODE_LOWER,j)!=0) {
         OrderClose(OrderTicket(),OrderLots(),Ask,0,clrNONE);
         //Alert("Lower fractal found at bar ",j) ;
         break;
         }

    if(iFractals(Symbol(),1440,MODE_UPPER,j)!=0) {
         OrderModify(OrderTicket(),OrderOpenPrice(),iFractals(Symbol(),1440,MODE_UPPER,j),OrderTakeProfit(),0,clrNONE);
         //Alert("Upper fractal found at bar ",j) ;
         break;
         }
    }
    
    break;
    
    
              
              
              }
                 }
           }
        }
     }

}
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//---
   freshBullishOB();
   freshBearishOB();
   //setupBuyTP();
   //setupSellTP();
   liquidity();
   EventSetTimer(3600);
   
//      for(int u=0;u<ArraySize(filterB);u++){
//      if(filterB[u].on == true){
//         Print("FilterB Buy@ " + DoubleToString(filterB[u].open,5) + " TF: " +IntegerToString(filterB[u].timeframe) + " SL: " + DoubleToString(filterB[u].close,5));
//      }
//   
//   }
//   
//   for(int u=0;u<ArraySize(filterS);u++){
//      if(filterS[u].on == true){
//         Print("FilterS Sell@ " + DoubleToString(filterS[u].open,5) + " TF: " +IntegerToString(filterS[u].timeframe) + " SL: " + DoubleToString(filterS[u].close,5));
//      }
//   
//   }

//---
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//---

  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void OnTimer()
  {
   ArrayFree(trades);
   ArrayFree(trades1);
   ArrayFree(selltrades);
   ArrayFree(selltrades1);
   freshBearishOB();
   freshBullishOB();
//avoidDoubleTrouble();
   //setupBuyTP();
   //setupSellTP();
   liquidity();
   RefreshRates();
  }
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void turnOff()
  {
   if(Hour() <= endtime && Hour() >= starttime)
     {
      startEA = true;
     }
   else
     {
     
      startEA = false;
     }
  }



//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void OnTick()
  {

//---
//autoLots();

   if(AccountProfit() >= 400 || AccountBalance() >= 6400 || AccountEquity() >= 6400){
      closeBuyOrders();
      closeSellOrders();
      SendNotification("6% Achieved");
      ExpertRemove();
   }
   if(AccountProfit() <= -250 || AccountBalance() >= 5750 || AccountEquity() >= 5750){
      closeBuyOrders();
      closeSellOrders();
      SendNotification("Challenge Failed");
      ExpertRemove();
   }
   //if(isNewCandle())
   //  {
   //   ArrayFree(trades);
   //   ArrayFree(trades1);
   //   ArrayFree(selltrades);
   //   ArrayFree(selltrades1);
   //   freshBearishOB(); //scan for specific buy points
   //   freshBullishOB(); //scan for specific sell points
   //   //avoidDoubleTrouble();
   //   //setupBuyTP();
   //   //setupSellTP();
   //   liquidity();
   //   RefreshRates();
   //  }
   trailingStop();

   turnOff(); //close all trades at 3pm everyday
   turnOffWeekends();

//stoplossHit();

   //test1(); //determine whether to buy or sell today
      
   hedgeTrigger3();
   
   //avoidDoubleTrouble();
   
   //fractalStopLoss();
   

   if(startEA) //start expert advisor if there are no orders today
     {

      //if(buySignal){
      for(int i=0; i<ArraySize(trades1); i++)
        {

         if((Ask <= (trades1[i].price)) && (Ask > trades1[i].close) && trades1[i].on == true && TotalBuyOrders() < 1 && TotalSellOrders() < 1 && (trades1[i].price - trades1[i].stop) > (63*Point))
           {
            //Print("Buy@ "+trades1[i].price+" Ask: "+Ask+"SL@ "+trades1[i].stop+ "TP@ "+(Ask + 100*Point));
            double l = NormalizeDouble(((risk * AccountBalance()) / ((trades1[i].price - trades1[i].stop) / Point)),2); //risk R% on any trade
            currentbuystop = trades1[i].stop;
            OrderSend(Symbol(),OP_BUY,Lots,Ask,100,trades1[i].stop,trades1[i].tp,NULL,1,0,clrNONE);
            posi = trades1[i].pos;
            trades1[i].on = false;
            currentLots = l;
            prevopen = Ask;
            prevstop = trades1[i].stop;

           }
         

        }
        //}

      //if(sellSignal){
      for(int i=0; i<ArraySize(selltrades1); i++)
        {

         if((Bid >= (selltrades1[i].price)) && (Bid < selltrades1[i].close) && selltrades1[i].on == true && TotalSellOrders() < 1 && TotalBuyOrders() < 1 && (selltrades1[i].stop - selltrades1[i].price) > (63*Point))
           {
            //Print("Sell@ "+selltrades1[i].price+" Bid: "+Bid+" SL@ "+selltrades1[i].stop+ " TP@ "+ selltrades1[i].tp);
            double l = NormalizeDouble(((risk * AccountBalance()) / ((selltrades1[i].stop - selltrades1[i].price) / Point)),2); //risk R% on any trade
            currentsellstop = selltrades1[i].stop;
            OrderSend(Symbol(),OP_SELL,Lots,Bid,100,selltrades1[i].stop,selltrades1[i].tp,NULL,1,0,clrNONE);
            posi = selltrades1[i].pos;
            selltrades1[i].on = false;
            currentLots = l;
            prevopen = Bid;
            prevstop = selltrades1[i].stop;
           }
         
        }
        //}

     }
  }

//+------------------------------------------------------------------+

